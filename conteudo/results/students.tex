\section{Study with University Students}

As presented in chapter \ref{cha:method}, we propose to students to mitigate duplications
found by the ArKanjo tool and send patches to the linux subsystems maintainers, while
documenting their experiences and learning through the process. 

For the students that worked
in the IIO subsytems, we gave them duplicated function pairs found by the tool and their 
responsability was to think of how to mitigate the duplication and sent the patch to the 
maintainers. The student that worked in the AMD Display driver have the additional work
to use the tool to find the duplications.

Appendix \ref{app:stuart} has references
to the artifacts discussed in this section, including the duplication function pairs that students 
mitigate, the students's reports, the patch students sent to the linux kernel, and the 
answers of the questionary asked to the student that worked in the AMD Display driver and the 
teaching assistant that used the tool to find duplications in the IIO.

\input{conteudo/results/table_students}

Table \ref{tab:stu} summarizes the mitigation approachs of students's groups in terms 
of lines changed and refactor methods used. A total of seven groups applied the parameterize refactor method,
and two groups applied the extractor method on their approaches to mitigate the duplications. 
The other three groups does not applied any refactor methods presented in the literature. 
We discuss the groups's approaches and the subsystem maintainers opinions on the patches that students
sent.

Groups one and four have worked in similar duplications, where there are two functions returning a boolean mirroring
the results. That means, when the first function returns true, the second function returns false, and when the first
functions returns false, the second function return false. The group one have a simple approach and the maintainers 
approved the changes quickly. The group four attempted to mitigate the duplication with macros, which is a method 
found in the code file they were working. The maintainers disagree with the proposed approach, arguing 
that the proposed changes decreases the code readability and asked for a approach similar to the group one. 
The group four submitted the patch after coding the approach proposed by the maintainers.

Group three, six and ten created a struct to encapsulate the parameters to mitigate the duplication when 
applying the parameterize method. The group three mitigation was send to the maintainers and the approved 
without significant comments, while the patch from group ten was reject by the same maintainer that approved
the patch from group three. The maintainer justification to reject the patch is that group ten refactored 
code files that has simple context, threfore adding a layer of abstraction to remove a duplication 
deacrease the code readability without clear gains on the codebase quality.

Group seven and eight used the extract method to approach the mitigations. The group eight send the 
mitigations to the maintainers and the code changes was approved with minor requested changes
about code style and smaller errors fix. For the group seven mitigation, the maintainers reject 
their patch because the code changes adds layers of abstractions on the code, turning it more complex
and harder to read. The maintainers proposed to the group seven to remove the duplicated functions 
and insert the duplicated code multiple times were the functions were being called. 
This suggestion we could think that it is a bad practice for code quality, as adds more complexity and 
responsibality to a bigger function, it is view as the best choice for removing layers of abstraction 
and making the code easier to read.

Group nine and eleven faced similar issue as us, where configurations files
designed as macros complicates to approach the mitigations. Group nine applied the parameterize method
to not need to know the configurations in the generic function, which is reasonable as the duplication
approach only depends on one configuration value. Group eleven worked with multiple configuration values,
and to refactor the duplication they proposed to create a bigger macro that encapsulates the other macros,
which is a clever solution but adds abstraction and complexity on macros, which makes the code harder
to debug and read. We do not get the feedback of the maintainers on the group eleven approach to know their 
opinions.

Group twelve is the student that executed the tool and pass throught the process of findings duplications.
The student found a duplication in the driver that happens accross eighteen code files, creating a patch
of removing four hundreds lines of duplicated code. 
The student send the mitigations to the maintainers and their feedback pointed to fix warning in the code, 
without arguing about removing the duplications.

Analysing the students approaches for the duplications and the maintainers feedback, 
we saw that people without previous experience in the linux kernel development could approach 
duplications found by the ArKanjo tool and become contributors to the kernel. We observed that 
not all duplications are view as code with bad quality, with the maintainers analysing the trade off
between what is the purpose of the duplicated code, the code readability, and the levels of abstraction 
added to address the duplications.

\subsection{Survey Results Analysis}

We asked for the teaching assistant and the student that used the ArKanjo to answer a survey with some 
question related to the tool experience, such as installation, documentation, facility of use, new ideas
to improve the tool, etc. Appendix \ref{app:survey} has the complete survey with the answers.

Related to the tool installation, the teaching assistant nor the students faced issues installing on the
Debian distributions, although the teaching assistant attempted to install in the Arch Linux distribution and
failed to install on this linux distribution.  About the tool documentation, the teaching assistant pointed errors in 
the documentation that worsed his experience. The student asked for more examples 
and tutorials on using the tool, in text or video formats. 

On the ArKanjo tool preprocessing step, the student reported problems of disk space usage and crash errors,
which we knew that could happen as the tool iterates and can save information about every pair of functions in
a codebase, as we did not implemented any mechanism to control the memory usage. The teaching assistant reported 
to only be able to execute the preprocessor with the \textit{gensim} similarity method, and the \textit{diff}
method kepted running for hours without finishing. This was a unexpected behaviour to us, as the \textit{gensim}
is a text similarity method while the \textit{diff} method is a simple counter of common lines with a operation system
default command. The teaching assistant report corroborate the \textit{gensim} efficiency.

Related to the functionalites of the tool, both the student assistant and the student 
reported a missing of a mechanism to save the tool results on a separated file instead of the terminal output.
The tool by default outputted with colors as show in the section \ref{subsec:func}, which complicates to redirect
the terminal output to a file.

We asked the overall impression of the tool and if met their expectations and to give a score from one 
to five to installation, documentation, preprocessing, and functionalites. 
Both the teaching assistant and the student gave a score of at least 4 to each mentioned point,
thought that the tool fulfill their expectations and have a overall good experience.

Finally, the teaching assistant the the student reported features ideas to the tool that may be interesting, which 
is as follow:

\begin{itemize}

\item Enable the possibility to have several codebases preprocessor artifacts and to select one of them.

\item Addition of different methods to find duplication.

\item Addition of more filters to search duplication, such as , find duplicates with
more than 90\% of similarity and more than 20 lines repeated.

\item Addition of options to highligh and filter duplications that happen on same file or directory.

\item Addition of support to save the tool output in files without manual preprocessing of the colored output.

\end{itemize}

With the survey feedback, we understood the the users had a good experience and found value in the ArKanjo tool,
and provided critical points that could be improved in the tool. The most critical issues reported had been fixed,
such as documentation errors and support for multiple linux distribution and different operation system. 
The less critical issues became a open point that can be addressed in future works.

\subsection{Students Contribution to the Tool}

For the two groups opted to contribute directly to the ArKanjo tool development, 
we listed multiple issues existed in the tool. The first group opted for working 
in expand the tool suport for multiple operation systems. Some libraries used in the 
tool development only had support for the Ubuntu distribution, and the first group was 
responsible to migrate these libraries to libraries that have support to multiple operation
systems. This issue was of our knowledge and pointed by the teaching assistant in the survey, as 
he faced the issue while using the tool.

The second group opted for working in a webpage for the tool documentation and support 
for light and dark mode. The colored output presented in the figures in Chapter \ref{cha:tool} 
were hard coded at first, does not considering the user terminal colors, 
thus giving a bad user experience. The website is helpfull to 
faciliate people to contribute or use the tool. We did not know how to approach the light and 
dark mode at first and have not needed to look on how
to fix the issue as the group search and found a solution on his own. 

The students successfully delivered the issues fix proposed. We found interesting to see 
people able to contribute to the tool on issues that even us did not know how to approach.
The issues helps the user experience and facilitates other researches using the ArKanjo tool 
that we may explore in future works. Appendix \ref{app:contribution} has references to the
students contributions, the issue list proposed to the students and figures of the 
documentation webpage.
