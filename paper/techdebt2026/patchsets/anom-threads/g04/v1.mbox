Subject: [PATCH v1] iio: adc: ad7091r-base: Move reg volatility check to new macro

Both ad7091r_writeable_reg() and ad7091r_volatile_reg() perform the
same test, checking whether a given 'reg' code is
AD7091R_REG_RESULT or AD7091R_REG_ALERT. While ad7091r_volatile_reg
returned true, ad7091r_writeable_reg returned false for the same
condition. As such, both functions introduced duplicate code.

We chose to implement the test as the AD7091R_IS_VOLATILE_REG
macro to remove the duplicate code without introducing new
function calls, which would be the case if we chose to fix the
duplicate code with one of the two following alternatives:

 A) Extracting a new function out of the test

 B) Rewriting ad7091r_writeable_reg to call
    ad7091r_volatile_reg or vice-versa.

Signed-off-by: ############# <####################>
Co-developed-by: ############# <####################>
Signed-off-by: ############# <####################>
Co-developed-by: ############# <###############>
Signed-off-by: ############# <###############>
---
 drivers/iio/adc/ad7091r-base.c | 16 ++--------------
 drivers/iio/adc/ad7091r-base.h |  2 ++
 2 files changed, 4 insertions(+), 14 deletions(-)

diff --git a/drivers/iio/adc/ad7091r-base.c b/drivers/iio/adc/ad7091r-base.c
index 931ff71b2888..8329552f0be8 100644
--- a/drivers/iio/adc/ad7091r-base.c
+++ b/drivers/iio/adc/ad7091r-base.c
@@ -375,25 +375,13 @@ EXPORT_SYMBOL_NS_GPL(ad7091r_probe, "IIO_AD7091R");
 
 bool ad7091r_writeable_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case AD7091R_REG_RESULT:
-	case AD7091R_REG_ALERT:
-		return false;
-	default:
-		return true;
-	}
+	return !AD7091R_IS_VOLATILE_REG(reg);
 }
 EXPORT_SYMBOL_NS_GPL(ad7091r_writeable_reg, "IIO_AD7091R");
 
 bool ad7091r_volatile_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case AD7091R_REG_RESULT:
-	case AD7091R_REG_ALERT:
-		return true;
-	default:
-		return false;
-	}
+	return AD7091R_IS_VOLATILE_REG(reg);
 }
 EXPORT_SYMBOL_NS_GPL(ad7091r_volatile_reg, "IIO_AD7091R");
 
diff --git a/drivers/iio/adc/ad7091r-base.h b/drivers/iio/adc/ad7091r-base.h
index 092ddea0f395..1b4e0ef43260 100644
--- a/drivers/iio/adc/ad7091r-base.h
+++ b/drivers/iio/adc/ad7091r-base.h
@@ -17,6 +17,8 @@
 #define AD7091R_REG_CH_LOW_LIMIT(ch) ((ch) * 3 + 4)
 #define AD7091R_REG_CH_HIGH_LIMIT(ch) ((ch) * 3 + 5)
 #define AD7091R_REG_CH_HYSTERESIS(ch) ((ch) * 3 + 6)
+#define AD7091R_IS_VOLATILE_REG(reg) (reg == AD7091R_REG_RESULT \
+	|| reg == AD7091R_REG_ALERT)
 
 /* AD7091R_REG_RESULT */
 #define AD7091R5_REG_RESULT_CH_ID(x)	    (((x) >> 13) & 0x3)
-- 
2.25.1


Subject: Re: [PATCH v1] iio: adc: ad7091r-base: Move reg volatility check to
 new macro

On ################, ############# wrote:
> Both ad7091r_writeable_reg() and ad7091r_volatile_reg() perform the
> same test, checking whether a given 'reg' code is
> AD7091R_REG_RESULT or AD7091R_REG_ALERT. While ad7091r_volatile_reg
> returned true, ad7091r_writeable_reg returned false for the same
> condition. As such, both functions introduced duplicate code.
> 
> We chose to implement the test as the AD7091R_IS_VOLATILE_REG
> macro to remove the duplicate code without introducing new
> function calls, which would be the case if we chose to fix the
> duplicate code with one of the two following alternatives:
> 
>  A) Extracting a new function out of the test
> 
>  B) Rewriting ad7091r_writeable_reg to call
>     ad7091r_volatile_reg or vice-versa.
> 
> Signed-off-by: ############# <####################>
> Co-developed-by: ############# <####################>
> Signed-off-by: ############# <####################>
> Co-developed-by: ############# <###############>
> Signed-off-by: ############# <###############>
> ---
>  drivers/iio/adc/ad7091r-base.c | 16 ++--------------
>  drivers/iio/adc/ad7091r-base.h |  2 ++
>  2 files changed, 4 insertions(+), 14 deletions(-)
> 
> diff --git a/drivers/iio/adc/ad7091r-base.c b/drivers/iio/adc/ad7091r-base.c
> index 931ff71b2888..8329552f0be8 100644
> --- a/drivers/iio/adc/ad7091r-base.c
> +++ b/drivers/iio/adc/ad7091r-base.c
> @@ -375,25 +375,13 @@ EXPORT_SYMBOL_NS_GPL(ad7091r_probe, "IIO_AD7091R");
>  
>  bool ad7091r_writeable_reg(struct device *dev, unsigned int reg)
>  {
> -	switch (reg) {
> -	case AD7091R_REG_RESULT:
> -	case AD7091R_REG_ALERT:
> -		return false;
> -	default:
> -		return true;
> -	}
> +	return !AD7091R_IS_VOLATILE_REG(reg);
>  }
>  EXPORT_SYMBOL_NS_GPL(ad7091r_writeable_reg, "IIO_AD7091R");
>  
>  bool ad7091r_volatile_reg(struct device *dev, unsigned int reg)
>  {
> -	switch (reg) {
> -	case AD7091R_REG_RESULT:
> -	case AD7091R_REG_ALERT:
> -		return true;
> -	default:
> -		return false;
> -	}
> +	return AD7091R_IS_VOLATILE_REG(reg);
>  }
>  EXPORT_SYMBOL_NS_GPL(ad7091r_volatile_reg, "IIO_AD7091R");
>  
> diff --git a/drivers/iio/adc/ad7091r-base.h b/drivers/iio/adc/ad7091r-base.h
> index 092ddea0f395..1b4e0ef43260 100644
> --- a/drivers/iio/adc/ad7091r-base.h
> +++ b/drivers/iio/adc/ad7091r-base.h
> @@ -17,6 +17,8 @@
>  #define AD7091R_REG_CH_LOW_LIMIT(ch) ((ch) * 3 + 4)
>  #define AD7091R_REG_CH_HIGH_LIMIT(ch) ((ch) * 3 + 5)
>  #define AD7091R_REG_CH_HYSTERESIS(ch) ((ch) * 3 + 6)
> +#define AD7091R_IS_VOLATILE_REG(reg) (reg == AD7091R_REG_RESULT \
> +	|| reg == AD7091R_REG_ALERT)
>  
>  /* AD7091R_REG_RESULT */
>  #define AD7091R5_REG_RESULT_CH_ID(x)	    (((x) >> 13) & 0x3)

TBH, I think the old code is more readable than hiding the values in a macro
even if it is duplicating a few lines of code.

But if everyone else thinks this is better, I would at least suggest to make
the macro AD7091R_IS_READ_ONLY_REG instead of volatile. Using not volatile
as an indicator of writable seems really strange. But using readonly as an
indication of volatile seems more logical. A comment to the effect of "the
read-only registers also happen to be the only volatile registers" in the
ad7091r_volatile_reg() function would help too.


Subject: Re: [PATCH v1] iio: adc: ad7091r-base: Move reg volatility check to
 new macro

Hello ######, #####, #####,

Your patch looks good to me. Just one comment inline.
With the macro updated according to suggestion
Reviewed-by: ############### <##########################>

On #####, ############# wrote:
> From: ############# <####################>
> 
> Both ad7091r_writeable_reg() and ad7091r_volatile_reg() perform the
> same test, checking whether a given 'reg' code is
> AD7091R_REG_RESULT or AD7091R_REG_ALERT. While ad7091r_volatile_reg
> returned true, ad7091r_writeable_reg returned false for the same
> condition. As such, both functions introduced duplicate code.
> 
> We chose to implement the test as the AD7091R_IS_VOLATILE_REG
> macro to remove the duplicate code without introducing new
> function calls, which would be the case if we chose to fix the
> duplicate code with one of the two following alternatives:
> 
>  A) Extracting a new function out of the test
> 
>  B) Rewriting ad7091r_writeable_reg to call
>     ad7091r_volatile_reg or vice-versa.
> 
> Signed-off-by: ############# <####################>
> Co-developed-by: ############# <####################>
> Signed-off-by: ############# <####################>
> Co-developed-by: ############# <###############>
> Signed-off-by: ############# <###############>
> ---
...
> diff --git a/drivers/iio/adc/ad7091r-base.h b/drivers/iio/adc/ad7091r-base.h
> index 092ddea0f395..1b4e0ef43260 100644
> --- a/drivers/iio/adc/ad7091r-base.h
> +++ b/drivers/iio/adc/ad7091r-base.h
> @@ -17,6 +17,8 @@
>  #define AD7091R_REG_CH_LOW_LIMIT(ch) ((ch) * 3 + 4)
>  #define AD7091R_REG_CH_HIGH_LIMIT(ch) ((ch) * 3 + 5)
>  #define AD7091R_REG_CH_HYSTERESIS(ch) ((ch) * 3 + 6)
> +#define AD7091R_IS_VOLATILE_REG(reg) (reg == AD7091R_REG_RESULT \
> +	|| reg == AD7091R_REG_ALERT)
Can we have the macro implementation all in one line?

#define AD7091R_IS_VOLATILE_REG(reg)					\
	((reg) == AD7091R_REG_RESULT || (reg) == AD7091R_REG_ALERT)

The extra () around reg is to make sure the expression is fully evaluated before
comparing to the address.

Thanks,
#######

Subject: Re: [PATCH v1] iio: adc: ad7091r-base: Move reg volatility check to
 new macro

...
> > diff --git a/drivers/iio/adc/ad7091r-base.h b/drivers/iio/adc/ad7091r-base.h
> > index 092ddea0f395..1b4e0ef43260 100644
> > --- a/drivers/iio/adc/ad7091r-base.h
> > +++ b/drivers/iio/adc/ad7091r-base.h
> > @@ -17,6 +17,8 @@
> >  #define AD7091R_REG_CH_LOW_LIMIT(ch) ((ch) * 3 + 4)
> >  #define AD7091R_REG_CH_HIGH_LIMIT(ch) ((ch) * 3 + 5)
> >  #define AD7091R_REG_CH_HYSTERESIS(ch) ((ch) * 3 + 6)
> > +#define AD7091R_IS_VOLATILE_REG(reg) (reg == AD7091R_REG_RESULT \
> > +	|| reg == AD7091R_REG_ALERT)
> >  
> >  /* AD7091R_REG_RESULT */
> >  #define AD7091R5_REG_RESULT_CH_ID(x)	    (((x) >> 13) & 0x3)
> 
> TBH, I think the old code is more readable than hiding the values in a macro
> even if it is duplicating a few lines of code.
> 
> But if everyone else thinks this is better, I would at least suggest to make
> the macro AD7091R_IS_READ_ONLY_REG instead of volatile. Using not volatile
> as an indicator of writable seems really strange. But using readonly as an
> indication of volatile seems more logical. A comment to the effect of "the
> read-only registers also happen to be the only volatile registers" in the
> ad7091r_volatile_reg() function would help too.
> 
>From my side, no strong preference between having the expanded code or a macro.
About the name, I was thinking about it the other way around. All
ad7091r-2/-4/-5/-8 registers are writeable, except the ones that are updated by
the device itself and those are read only. Of course, that logic only applies
because ad7091r happens to not have any read only reg that is not volatile
(e.g. a device or vendor ID reg). Agree though that it would be nice to add
a comment clarifying why volatile regs are read only and vice-versa.

Subject: Re: [PATCH v1] iio: adc: ad7091r-base: Move reg volatility check to
 new macro

Thanks ##### and ####### for the feedback.
...
> > TBH, I think the old code is more readable than hiding the values in a macro
> > even if it is duplicating a few lines of code.
> >
> > But if everyone else thinks this is better, I would at least suggest to make
> > the macro AD7091R_IS_READ_ONLY_REG instead of volatile. Using not volatile
> > as an indicator of writable seems really strange. But using readonly as an
> > indication of volatile seems more logical. A comment to the effect of "the
> > read-only registers also happen to be the only volatile registers" in the
> > ad7091r_volatile_reg() function would help too.
> >
> From my side, no strong preference between having the expanded code or a macro.
> About the name, I was thinking about it the other way around. All
> ad7091r-2/-4/-5/-8 registers are writeable, except the ones that are updated by
> the device itself and those are read only. Of course, that logic only applies
> because ad7091r happens to not have any read only reg that is not volatile
> (e.g. a device or vendor ID reg). Agree though that it would be nice to add
> a comment clarifying why volatile regs are read only and vice-versa.

I, too, agree with you and see that a comment would be adequate.

Regarding the name of the macro, I see David's suggestion as being
slightly more
intuitive. Otherwise, someone might eventually argue that the same comment on
the read-only volatile registers should accompany the definition of the macro.

I'm addressing your comments on a new patch.

Thank you,
######

